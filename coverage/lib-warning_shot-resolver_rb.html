    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>lib/warning_shot/resolver.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
        <p>Generated on Fri Oct 17 09:27:19 -0700 2008 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
        </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='lib-warning_shot-resolver_rb.html'>lib/warning_shot/resolver.rb</a>
          </td>
          <td class='lines_total'>
            <tt>568</tt>
          </td>
          <td class='lines_code'>
            <tt>209</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_total'>96.7%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='97' />
                      <td class='uncovered' width='3' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_code'>92.3%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='92' />
                      <td class='uncovered' width='8' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="inferred0"><a name="line1"></a>  1 # API access for resolvers
</span><span class="inferred1"><a name="line2"></a>  2 #
</span><span class="inferred0"><a name="line3"></a>  3 # @example
</span><span class="inferred1"><a name="line4"></a>  4 #   require 'warningshot'
</span><span class="inferred0"><a name="line5"></a>  5 #   class MyCustomResolver
</span><span class="inferred1"><a name="line6"></a>  6 #     include WarningShot::Resolver
</span><span class="inferred0"><a name="line7"></a>  7 #   end
</span><span class="inferred1"><a name="line8"></a>  8 #
</span><span class="inferred0"><a name="line9"></a>  9 # @api private
</span><span class="marked1"><a name="line10"></a> 10 module WarningShot
</span><span class="marked0"><a name="line11"></a> 11   module Resolver
</span><span class="marked1"><a name="line12"></a> 12     module ClassMethods
</span><span class="marked0"><a name="line13"></a> 13       DefaultRescues = {:test =&gt; true, :resolve =&gt; true}
</span><span class="marked1"><a name="line14"></a> 14       attr_reader :raw_cli_ext
</span><span class="inferred0"><a name="line15"></a> 15       
</span><span class="inferred1"><a name="line16"></a> 16       # extends command line interface
</span><span class="inferred0"><a name="line17"></a> 17       # 
</span><span class="inferred1"><a name="line18"></a> 18       # @param opts [Hash]
</span><span class="inferred0"><a name="line19"></a> 19       #     Keys and example values
</span><span class="inferred1"><a name="line20"></a> 20       #       :short =&gt; &quot;-s&quot;,
</span><span class="inferred0"><a name="line21"></a> 21       #       :long =&gt; &quot;--longflag&quot;,
</span><span class="inferred1"><a name="line22"></a> 22       #       :default =&gt; &quot;my_value&quot;,
</span><span class="inferred0"><a name="line23"></a> 23       #       :description =&gt; &quot;Command line description&quot;,
</span><span class="inferred1"><a name="line24"></a> 24       #       :name =&gt; &quot;keyname&quot;, #required
</span><span class="inferred0"><a name="line25"></a> 25       #       :type =&gt; String #[:list, :of, :available, :values]
</span><span class="inferred1"><a name="line26"></a> 26       #       :default_desc =&gt; &quot;Default: my_value&quot;
</span><span class="inferred0"><a name="line27"></a> 27       # @api public
</span><span class="marked1"><a name="line28"></a> 28       def cli(opts)
</span><span class="marked0"><a name="line29"></a> 29         @raw_cli_ext ||= []
</span><span class="inferred1"><a name="line30"></a> 30         #Do not extend the interface if the class is being 
</span><span class="marked0"><a name="line31"></a> 31         return if self.disabled?
</span><span class="inferred1"><a name="line32"></a> 32         
</span><span class="inferred0"><a name="line33"></a> 33         ##A keyname for the option is required
</span><span class="marked1"><a name="line34"></a> 34         return if opts[:name].nil?
</span><span class="marked0"><a name="line35"></a> 35         @raw_cli_ext &lt;&lt; opts
</span><span class="inferred1"><a name="line36"></a> 36         
</span><span class="marked0"><a name="line37"></a> 37         clean_opts = [
</span><span class="inferred1"><a name="line38"></a> 38           opts[:short],
</span><span class="inferred0"><a name="line39"></a> 39           opts[:long],
</span><span class="inferred1"><a name="line40"></a> 40           opts[:type],
</span><span class="inferred0"><a name="line41"></a> 41           opts[:description],
</span><span class="inferred1"><a name="line42"></a> 42           opts[:default_desc]
</span><span class="inferred0"><a name="line43"></a> 43         ]
</span><span class="marked1"><a name="line44"></a> 44         clean_opts.delete(nil)
</span><span class="inferred0"><a name="line45"></a> 45         
</span><span class="inferred1"><a name="line46"></a> 46         #Set the default value if it was given
</span><span class="marked0"><a name="line47"></a> 47         opt_name = opts[:name].intern
</span><span class="marked1"><a name="line48"></a> 48         WarningShot::Config[opt_name] = opts[:default]
</span><span class="inferred0"><a name="line49"></a> 49         
</span><span class="marked1"><a name="line50"></a> 50         WarningShot.parser.on_tail(*clean_opts) do |val|
</span><span class="uncovered0"><a name="line51"></a> 51           WarningShot::Config[opt_name] = val
</span><span class="uncovered1"><a name="line52"></a> 52         end
</span><span class="uncovered0"><a name="line53"></a> 53 
</span><span class="uncovered1"><a name="line54"></a> 54       end
</span><span class="inferred0"><a name="line55"></a> 55       
</span><span class="inferred1"><a name="line56"></a> 56       # Setter/Getter for resolver branch, 
</span><span class="inferred0"><a name="line57"></a> 57       # used in outputting info and for determine which yaml to apply
</span><span class="inferred1"><a name="line58"></a> 58       #
</span><span class="inferred0"><a name="line59"></a> 59       # @param b [~to_s] 
</span><span class="inferred1"><a name="line60"></a> 60       #   branch in dependency tree to use
</span><span class="inferred0"><a name="line61"></a> 61       #
</span><span class="inferred1"><a name="line62"></a> 62       # @return [String]
</span><span class="inferred0"><a name="line63"></a> 63       #   Resolver's branch
</span><span class="inferred1"><a name="line64"></a> 64       #
</span><span class="inferred0"><a name="line65"></a> 65       # @example
</span><span class="inferred1"><a name="line66"></a> 66       #   class MyResolver
</span><span class="inferred0"><a name="line67"></a> 67       #     include WarningShot::Resolver
</span><span class="inferred1"><a name="line68"></a> 68       #     branch :mock
</span><span class="inferred0"><a name="line69"></a> 69       #   end
</span><span class="inferred1"><a name="line70"></a> 70       #
</span><span class="inferred0"><a name="line71"></a> 71       # @api public
</span><span class="marked1"><a name="line72"></a> 72       def branch(b=nil)
</span><span class="marked0"><a name="line73"></a> 73         @branch = b unless b.nil?
</span><span class="marked1"><a name="line74"></a> 74         @branch
</span><span class="inferred0"><a name="line75"></a> 75       end
</span><span class="inferred1"><a name="line76"></a> 76       
</span><span class="inferred0"><a name="line77"></a> 77       # Setter/Getter for resolver description, 
</span><span class="inferred1"><a name="line78"></a> 78       #
</span><span class="inferred0"><a name="line79"></a> 79       # @param d [~to_s] 
</span><span class="inferred1"><a name="line80"></a> 80       # Resolver's description
</span><span class="inferred0"><a name="line81"></a> 81       #
</span><span class="inferred1"><a name="line82"></a> 82       # @return [String]
</span><span class="inferred0"><a name="line83"></a> 83       #   Resolver's description
</span><span class="inferred1"><a name="line84"></a> 84       #
</span><span class="inferred0"><a name="line85"></a> 85       # @example
</span><span class="inferred1"><a name="line86"></a> 86       #   class MyResolver
</span><span class="inferred0"><a name="line87"></a> 87       #     include WarningShot::Resolver
</span><span class="inferred1"><a name="line88"></a> 88       #     description 'Mock resolver for rspec testing'
</span><span class="inferred0"><a name="line89"></a> 89       #   end
</span><span class="inferred1"><a name="line90"></a> 90       #
</span><span class="inferred0"><a name="line91"></a> 91       # @api public
</span><span class="marked1"><a name="line92"></a> 92       def description(d=nil)
</span><span class="marked0"><a name="line93"></a> 93         @description = d unless d.nil?
</span><span class="marked1"><a name="line94"></a> 94         @description
</span><span class="inferred0"><a name="line95"></a> 95       end
</span><span class="inferred1"><a name="line96"></a> 96         
</span><span class="inferred0"><a name="line97"></a> 97       # Setter/Getter for resolver order, 
</span><span class="inferred1"><a name="line98"></a> 98       # determines order in which resolver is checked
</span><span class="inferred0"><a name="line99"></a> 99       #
</span><span class="inferred1"><a name="line100"></a>100       # @param p [Fixnum] (optional; default 100)
</span><span class="inferred0"><a name="line101"></a>101       #   Resolver's order, lower the earlier it is run
</span><span class="inferred1"><a name="line102"></a>102       #
</span><span class="inferred0"><a name="line103"></a>103       # @return [Fixnum]
</span><span class="inferred1"><a name="line104"></a>104       #   Resolver's order
</span><span class="inferred0"><a name="line105"></a>105       #
</span><span class="inferred1"><a name="line106"></a>106       # @example
</span><span class="inferred0"><a name="line107"></a>107       #   class MyResolver
</span><span class="inferred1"><a name="line108"></a>108       #     include WarningShot::Resolver
</span><span class="inferred0"><a name="line109"></a>109       #     order 1 # Would attempt to run this resolver check first
</span><span class="inferred1"><a name="line110"></a>110       #     #order 1000
</span><span class="inferred0"><a name="line111"></a>111       #   end
</span><span class="inferred1"><a name="line112"></a>112       #
</span><span class="inferred0"><a name="line113"></a>113       # @api public
</span><span class="marked1"><a name="line114"></a>114       def order(p=nil)
</span><span class="marked0"><a name="line115"></a>115         @order = p unless p.nil?
</span><span class="marked1"><a name="line116"></a>116         @order
</span><span class="inferred0"><a name="line117"></a>117       end
</span><span class="inferred1"><a name="line118"></a>118       
</span><span class="inferred0"><a name="line119"></a>119       # Sets a resolver to disabled mode, won't be processed
</span><span class="inferred1"><a name="line120"></a>120       #
</span><span class="inferred0"><a name="line121"></a>121       # @example
</span><span class="inferred1"><a name="line122"></a>122       #   class MyResolver
</span><span class="inferred0"><a name="line123"></a>123       #     include WarningShot::Resolver
</span><span class="inferred1"><a name="line124"></a>124       #     disable!
</span><span class="inferred0"><a name="line125"></a>125       #   end
</span><span class="inferred1"><a name="line126"></a>126       #
</span><span class="inferred0"><a name="line127"></a>127       # @api public
</span><span class="marked1"><a name="line128"></a>128       def disable!
</span><span class="marked0"><a name="line129"></a>129         @disabled = true
</span><span class="marked1"><a name="line130"></a>130       end
</span><span class="inferred0"><a name="line131"></a>131       
</span><span class="inferred1"><a name="line132"></a>132       # Determines if resolver is disabled
</span><span class="inferred0"><a name="line133"></a>133       #
</span><span class="inferred1"><a name="line134"></a>134       # @return [Boolean]
</span><span class="inferred0"><a name="line135"></a>135       #   is it disabled
</span><span class="inferred1"><a name="line136"></a>136       #
</span><span class="inferred0"><a name="line137"></a>137       # @api public
</span><span class="marked1"><a name="line138"></a>138       def disabled?
</span><span class="marked0"><a name="line139"></a>139         @disabled ||=false
</span><span class="marked1"><a name="line140"></a>140       end
</span><span class="inferred0"><a name="line141"></a>141       
</span><span class="inferred1"><a name="line142"></a>142       # Provides resolver access to warningshots logger
</span><span class="inferred0"><a name="line143"></a>143       #
</span><span class="inferred1"><a name="line144"></a>144       # @return [~Logger]
</span><span class="inferred0"><a name="line145"></a>145       #   WarningShots logger
</span><span class="inferred1"><a name="line146"></a>146       #
</span><span class="inferred0"><a name="line147"></a>147       # @api public
</span><span class="marked1"><a name="line148"></a>148       def logger
</span><span class="marked0"><a name="line149"></a>149         WarningShot.logger
</span><span class="marked1"><a name="line150"></a>150       end
</span><span class="inferred0"><a name="line151"></a>151       
</span><span class="inferred1"><a name="line152"></a>152       # Sets if the test/resolve blocks should be wrapped in resuce statements
</span><span class="inferred0"><a name="line153"></a>153       #   This will allow WarningShot to output a nice error message and continue
</span><span class="inferred1"><a name="line154"></a>154       #   testing other dependencies rather than exit
</span><span class="inferred0"><a name="line155"></a>155       #
</span><span class="inferred1"><a name="line156"></a>156       # @param r [Boolean|Hash]
</span><span class="inferred0"><a name="line157"></a>157       #   Does it need to be rescued
</span><span class="inferred1"><a name="line158"></a>158       #
</span><span class="inferred0"><a name="line159"></a>159       # @example
</span><span class="inferred1"><a name="line160"></a>160       #   MyMockResolver.rescue_me!   
</span><span class="inferred0"><a name="line161"></a>161       #     #=&gt; sets @needs_rescue =&gt; {:resolve =&gt; true, :test=&gt; true}
</span><span class="inferred1"><a name="line162"></a>162       #   MockResolver.rescue_me! :resolve =&gt; true 
</span><span class="inferred0"><a name="line163"></a>163       #     #=&gt; sets @needs_rescue =&gt; {:resolve =&gt; true, :test=&gt; false}
</span><span class="inferred1"><a name="line164"></a>164       #
</span><span class="inferred0"><a name="line165"></a>165       # @api public
</span><span class="inferred1"><a name="line166"></a>166       #def rescue_me!(r=nil)
</span><span class="inferred0"><a name="line167"></a>167       #  @needs_rescue = (r.is_a? Hash) ? r.merge(DefaultRescues) : DefaultRescues
</span><span class="inferred1"><a name="line168"></a>168       #end
</span><span class="inferred0"><a name="line169"></a>169       
</span><span class="inferred1"><a name="line170"></a>170       # Determines if method needs rescue
</span><span class="inferred0"><a name="line171"></a>171       #
</span><span class="inferred1"><a name="line172"></a>172       # @param method [Symbol] (:test | :resolve)
</span><span class="inferred0"><a name="line173"></a>173       #   method to check if it needs rescue
</span><span class="inferred1"><a name="line174"></a>174       #
</span><span class="inferred0"><a name="line175"></a>175       # @return [Boolean]
</span><span class="inferred1"><a name="line176"></a>176       #   Does it need rescue block 
</span><span class="inferred0"><a name="line177"></a>177       #
</span><span class="inferred1"><a name="line178"></a>178       # @api private
</span><span class="inferred0"><a name="line179"></a>179       #def needs_rescue?(meth)
</span><span class="inferred1"><a name="line180"></a>180       #  @needs_rescue ||= DefaultRescues
</span><span class="inferred0"><a name="line181"></a>181       #  !!(@needs_rescue[meth])
</span><span class="inferred1"><a name="line182"></a>182       #end
</span><span class="inferred0"><a name="line183"></a>183       
</span><span class="inferred1"><a name="line184"></a>184       # Defines how to cast YAML parsed data to an object
</span><span class="inferred0"><a name="line185"></a>185       #   the resolver can work with
</span><span class="inferred1"><a name="line186"></a>186       #
</span><span class="inferred0"><a name="line187"></a>187       # @param klass [Class]
</span><span class="inferred1"><a name="line188"></a>188       #   Type of class to perform casting against,
</span><span class="inferred0"><a name="line189"></a>189       #     if nil, the method is used on all types not matched
</span><span class="inferred1"><a name="line190"></a>190       #
</span><span class="inferred0"><a name="line191"></a>191       # @param block [lambda]
</span><span class="inferred1"><a name="line192"></a>192       #   How to cast the data to an object
</span><span class="inferred0"><a name="line193"></a>193       # 
</span><span class="inferred1"><a name="line194"></a>194       # @api public
</span><span class="marked0"><a name="line195"></a>195       def cast(klass=nil,&amp;block)
</span><span class="marked1"><a name="line196"></a>196         if klass.nil?
</span><span class="marked0"><a name="line197"></a>197           klass = :default
</span><span class="inferred1"><a name="line198"></a>198         else
</span><span class="marked0"><a name="line199"></a>199           klass = klass.name.to_sym
</span><span class="inferred1"><a name="line200"></a>200         end
</span><span class="marked0"><a name="line201"></a>201         (@yaml_to_object_methods||={})[klass] = block
</span><span class="inferred1"><a name="line202"></a>202       end
</span><span class="inferred0"><a name="line203"></a>203       
</span><span class="inferred1"><a name="line204"></a>204       # calls the block defined by Resolver#cast to convert
</span><span class="inferred0"><a name="line205"></a>205       #   the yaml data to an object
</span><span class="inferred1"><a name="line206"></a>206       #
</span><span class="inferred0"><a name="line207"></a>207       # @param data [~YAML::load]
</span><span class="inferred1"><a name="line208"></a>208       #   The data parsed from YAML::load
</span><span class="inferred0"><a name="line209"></a>209       #
</span><span class="inferred1"><a name="line210"></a>210       # @return [Object]
</span><span class="inferred0"><a name="line211"></a>211       #   The casted objects   
</span><span class="inferred1"><a name="line212"></a>212       #
</span><span class="inferred0"><a name="line213"></a>213       # @notes
</span><span class="inferred1"><a name="line214"></a>214       #   if Resolver#cast was not called, it will just return
</span><span class="inferred0"><a name="line215"></a>215       #     the YAML parsed data
</span><span class="inferred1"><a name="line216"></a>216       #
</span><span class="inferred0"><a name="line217"></a>217       # @api private
</span><span class="marked1"><a name="line218"></a>218       def yaml_to_object(data)       
</span><span class="marked0"><a name="line219"></a>219         @yaml_to_object_methods||={} 
</span><span class="marked1"><a name="line220"></a>220         klass = data.class.name.to_sym
</span><span class="inferred0"><a name="line221"></a>221 
</span><span class="inferred1"><a name="line222"></a>222         # if klass has a registered casting method, do it
</span><span class="marked0"><a name="line223"></a>223         if @yaml_to_object_methods.key? klass
</span><span class="marked1"><a name="line224"></a>224           return @yaml_to_object_methods[klass].call(data)
</span><span class="inferred0"><a name="line225"></a>225         # elsif there is a regsitered default method, do it.
</span><span class="marked1"><a name="line226"></a>226         elsif @yaml_to_object_methods.key? :default
</span><span class="marked0"><a name="line227"></a>227           return @yaml_to_object_methods[:default].call(data)
</span><span class="uncovered1"><a name="line228"></a>228         else
</span><span class="uncovered0"><a name="line229"></a>229         # else return original data
</span><span class="uncovered1"><a name="line230"></a>230           return data
</span><span class="uncovered0"><a name="line231"></a>231         end
</span><span class="uncovered1"><a name="line232"></a>232       end
</span><span class="inferred0"><a name="line233"></a>233             
</span><span class="inferred1"><a name="line234"></a>234       # Registers a test or resolution block
</span><span class="inferred0"><a name="line235"></a>235       #
</span><span class="inferred1"><a name="line236"></a>236       # @param type [Symbol]
</span><span class="inferred0"><a name="line237"></a>237       #   The type of block being registered :test | :resolution
</span><span class="inferred1"><a name="line238"></a>238       #
</span><span class="inferred0"><a name="line239"></a>239       # @param meta [Hash]
</span><span class="inferred1"><a name="line240"></a>240       #   :name [String] (Optional) 
</span><span class="inferred0"><a name="line241"></a>241       #       Name of the test
</span><span class="inferred1"><a name="line242"></a>242       #   :desc [String] (Optional) 
</span><span class="inferred0"><a name="line243"></a>243       #       Description of the test
</span><span class="inferred1"><a name="line244"></a>244       #   :if|:unless [lambda] (Optional)
</span><span class="inferred0"><a name="line245"></a>245       #       Block that returns ~boolean determining if the test applies
</span><span class="inferred1"><a name="line246"></a>246       #       The block will be passed the current item from config file
</span><span class="inferred0"><a name="line247"></a>247       #
</span><span class="inferred1"><a name="line248"></a>248       # @param block [lambda]
</span><span class="inferred0"><a name="line249"></a>249       #   block should return ~boolean result of resolution attempt
</span><span class="inferred1"><a name="line250"></a>250       #   The block will be passed the current item from config file
</span><span class="inferred0"><a name="line251"></a>251       #
</span><span class="inferred1"><a name="line252"></a>252       # @example
</span><span class="inferred0"><a name="line253"></a>253       #   register :test, :name =&gt; :awesome_test, :desc =&gt; &quot;this is my awesome test&quot; do |dependency|
</span><span class="inferred1"><a name="line254"></a>254       #     your_logic_that_tests dependency
</span><span class="inferred0"><a name="line255"></a>255       #   end
</span><span class="inferred1"><a name="line256"></a>256       #
</span><span class="inferred0"><a name="line257"></a>257       #   register :test, :if =&gt; lambda { |dependency|
</span><span class="inferred1"><a name="line258"></a>258       #     #This condition would determine if test should be run
</span><span class="inferred0"><a name="line259"></a>259       #     logic_that_determines_if_test_applies dependency
</span><span class="inferred1"><a name="line260"></a>260       #   } do |dependency|
</span><span class="inferred0"><a name="line261"></a>261       #     your_logic_that_tests dependency
</span><span class="inferred1"><a name="line262"></a>262       #   end
</span><span class="inferred0"><a name="line263"></a>263       
</span><span class="inferred1"><a name="line264"></a>264       #   register :resolution do |dependency|
</span><span class="inferred0"><a name="line265"></a>265       #     #Access to current dependency via dependency
</span><span class="inferred1"><a name="line266"></a>266       #     my_method_that_would_resolve dependency
</span><span class="inferred0"><a name="line267"></a>267       #   end
</span><span class="inferred1"><a name="line268"></a>268       #
</span><span class="inferred0"><a name="line269"></a>269       #   register :resolution, :if =&gt; lambda{|dependency| 
</span><span class="inferred1"><a name="line270"></a>270       #     #This will determin if resolution should be attempted
</span><span class="inferred0"><a name="line271"></a>271       #     # this would only resolve in production
</span><span class="inferred1"><a name="line272"></a>272       #     WarningShot.environment == 'production'
</span><span class="inferred0"><a name="line273"></a>273       #   } do |dependency|
</span><span class="inferred1"><a name="line274"></a>274       #       my_method_that_would_resolve dependency
</span><span class="inferred0"><a name="line275"></a>275       #   end
</span><span class="inferred1"><a name="line276"></a>276       #
</span><span class="inferred0"><a name="line277"></a>277       # @api public
</span><span class="marked1"><a name="line278"></a>278       def register(type, meta={}, &amp;block)
</span><span class="marked0"><a name="line279"></a>279         if meta[:if] &amp;&amp; meta[:unless]
</span><span class="marked1"><a name="line280"></a>280           raise Exception, &quot;:if and :unless cannot be specified on the same resolution&quot;
</span><span class="inferred0"><a name="line281"></a>281         end
</span><span class="inferred1"><a name="line282"></a>282         
</span><span class="marked0"><a name="line283"></a>283         @registered_blocks  ||= {:test =&gt; [], :resolution =&gt; []}
</span><span class="marked1"><a name="line284"></a>284         meta[type] = block
</span><span class="inferred0"><a name="line285"></a>285 
</span><span class="inferred1"><a name="line286"></a>286         # If a condition is given add to begining of array, if no condition
</span><span class="inferred0"><a name="line287"></a>287         #   add it to end.  This makes it so we dont have to sort later on :if|:unless
</span><span class="inferred1"><a name="line288"></a>288         #   to get non-condition resolutions to run last
</span><span class="inferred0"><a name="line289"></a>289         
</span><span class="marked1"><a name="line290"></a>290         if meta[:if] || meta[:unless]
</span><span class="marked0"><a name="line291"></a>291           @registered_blocks[type].unshift meta
</span><span class="inferred1"><a name="line292"></a>292         else
</span><span class="marked0"><a name="line293"></a>293           @registered_blocks[type] &lt;&lt; meta
</span><span class="inferred1"><a name="line294"></a>294         end
</span><span class="inferred0"><a name="line295"></a>295       end
</span><span class="inferred1"><a name="line296"></a>296       
</span><span class="inferred0"><a name="line297"></a>297       # Lists current resolver tests
</span><span class="inferred1"><a name="line298"></a>298       #
</span><span class="inferred0"><a name="line299"></a>299       # @param test_name [Symbol]
</span><span class="inferred1"><a name="line300"></a>300       #   find a test by name (if a name was given)
</span><span class="inferred0"><a name="line301"></a>301       #
</span><span class="inferred1"><a name="line302"></a>302       # @return [Hash|Array]
</span><span class="inferred0"><a name="line303"></a>303       #   When name given, returns test Hash
</span><span class="inferred1"><a name="line304"></a>304       #   When name not give, returns all test Hashes in an array
</span><span class="inferred0"><a name="line305"></a>305       #
</span><span class="inferred1"><a name="line306"></a>306       # @api private
</span><span class="marked0"><a name="line307"></a>307       def tests(test_name=nil)
</span><span class="marked1"><a name="line308"></a>308         unless test_name
</span><span class="marked0"><a name="line309"></a>309           @registered_blocks[:test] ||= []
</span><span class="inferred1"><a name="line310"></a>310         else
</span><span class="inferred0"><a name="line311"></a>311           return @registered_blocks[:test].find do |registered_test|
</span><span class="marked1"><a name="line312"></a>312             registered_test[:name] == test_name
</span><span class="marked0"><a name="line313"></a>313           end
</span><span class="inferred1"><a name="line314"></a>314         end
</span><span class="marked0"><a name="line315"></a>315       end
</span><span class="inferred1"><a name="line316"></a>316       
</span><span class="inferred0"><a name="line317"></a>317       # Lists current resolver resolutions
</span><span class="inferred1"><a name="line318"></a>318       #
</span><span class="inferred0"><a name="line319"></a>319       # @param resolution_name [Symbol]
</span><span class="inferred1"><a name="line320"></a>320       #   find a test by name (if a name was given)
</span><span class="inferred0"><a name="line321"></a>321       #
</span><span class="inferred1"><a name="line322"></a>322       # @api private
</span><span class="marked0"><a name="line323"></a>323       def resolutions(resolution_name=nil)
</span><span class="marked1"><a name="line324"></a>324         unless resolution_name
</span><span class="marked0"><a name="line325"></a>325           @registered_blocks[:resolution] ||= []
</span><span class="inferred1"><a name="line326"></a>326         else
</span><span class="inferred0"><a name="line327"></a>327           return @registered_blocks[:resolution].find do |registered_resolution|
</span><span class="marked1"><a name="line328"></a>328             registered_resolution[:name] == resolution_name
</span><span class="marked0"><a name="line329"></a>329           end
</span><span class="inferred1"><a name="line330"></a>330         end
</span><span class="marked0"><a name="line331"></a>331       end
</span><span class="inferred1"><a name="line332"></a>332       
</span><span class="inferred0"><a name="line333"></a>333       # Removes all tests from a resolver
</span><span class="inferred1"><a name="line334"></a>334       #
</span><span class="inferred0"><a name="line335"></a>335       # @api public
</span><span class="marked1"><a name="line336"></a>336       def flush_tests!
</span><span class="marked0"><a name="line337"></a>337         @registered_blocks[:test] = []
</span><span class="marked1"><a name="line338"></a>338       end
</span><span class="inferred0"><a name="line339"></a>339       
</span><span class="inferred1"><a name="line340"></a>340       # Removes all resolutions from a resolver
</span><span class="inferred0"><a name="line341"></a>341       #
</span><span class="inferred1"><a name="line342"></a>342       # @api public
</span><span class="marked0"><a name="line343"></a>343       def flush_resolutions!
</span><span class="marked1"><a name="line344"></a>344         @registered_blocks[:resolution] = []
</span><span class="marked0"><a name="line345"></a>345       end
</span><span class="inferred1"><a name="line346"></a>346       
</span><span class="inferred0"><a name="line347"></a>347       # add before filters to test/resolution blocks
</span><span class="inferred1"><a name="line348"></a>348       #
</span><span class="inferred0"><a name="line349"></a>349       # @param type Symbol
</span><span class="inferred1"><a name="line350"></a>350       #   run before :test | :resolution
</span><span class="inferred0"><a name="line351"></a>351       # @param block [lambda]
</span><span class="inferred1"><a name="line352"></a>352       #   block to run before tests or resolutions
</span><span class="inferred0"><a name="line353"></a>353       #
</span><span class="marked1"><a name="line354"></a>354       def before(type,&amp;block)
</span><span class="marked0"><a name="line355"></a>355         @before_filters ||= {:test=&gt;[],:resolution=&gt;[]}
</span><span class="marked1"><a name="line356"></a>356         @before_filters[type] &lt;&lt; block
</span><span class="inferred0"><a name="line357"></a>357       end
</span><span class="inferred1"><a name="line358"></a>358       
</span><span class="inferred0"><a name="line359"></a>359       # gets before filters for type
</span><span class="inferred1"><a name="line360"></a>360       #
</span><span class="inferred0"><a name="line361"></a>361       # @param type [Symbol]
</span><span class="inferred1"><a name="line362"></a>362       #   Type of filters to get
</span><span class="inferred0"><a name="line363"></a>363       # @return [Array[Proc]] 
</span><span class="inferred1"><a name="line364"></a>364       #   Before filters
</span><span class="inferred0"><a name="line365"></a>365       # @api
</span><span class="marked1"><a name="line366"></a>366       def before_filters(type)
</span><span class="marked0"><a name="line367"></a>367         @before_filters[type]
</span><span class="marked1"><a name="line368"></a>368       end
</span><span class="inferred0"><a name="line369"></a>369       
</span><span class="inferred1"><a name="line370"></a>370       # gets after filters for type
</span><span class="inferred0"><a name="line371"></a>371       #
</span><span class="inferred1"><a name="line372"></a>372       # @param type [Symbol]
</span><span class="inferred0"><a name="line373"></a>373       #   Type of filters to get
</span><span class="inferred1"><a name="line374"></a>374       # @return [Array[Proc]] 
</span><span class="inferred0"><a name="line375"></a>375       #   after filters
</span><span class="inferred1"><a name="line376"></a>376       # @api
</span><span class="marked0"><a name="line377"></a>377       def after_filters(type)
</span><span class="marked1"><a name="line378"></a>378         @after_filters[type]
</span><span class="marked0"><a name="line379"></a>379       end
</span><span class="inferred1"><a name="line380"></a>380 
</span><span class="inferred0"><a name="line381"></a>381       # add after filters to test/resolution blocks
</span><span class="inferred1"><a name="line382"></a>382       #
</span><span class="inferred0"><a name="line383"></a>383       # @param type Symbol
</span><span class="inferred1"><a name="line384"></a>384       #   run after :test | :resolution
</span><span class="inferred0"><a name="line385"></a>385       # @param block [lambda]
</span><span class="inferred1"><a name="line386"></a>386       #   block to run after tests or resolutions
</span><span class="inferred0"><a name="line387"></a>387       #      
</span><span class="marked1"><a name="line388"></a>388       def after(type,&amp;block)
</span><span class="marked0"><a name="line389"></a>389         @after_filters ||= {:test=&gt;[],:resolution=&gt;[]}
</span><span class="marked1"><a name="line390"></a>390         @after_filters[type] &lt;&lt; block
</span><span class="inferred0"><a name="line391"></a>391       end
</span><span class="inferred1"><a name="line392"></a>392       
</span><span class="inferred0"><a name="line393"></a>393       # Outputs class static details
</span><span class="inferred1"><a name="line394"></a>394       #
</span><span class="inferred0"><a name="line395"></a>395       # @return [Array(Object)]
</span><span class="inferred1"><a name="line396"></a>396       # @api private
</span><span class="marked0"><a name="line397"></a>397       def details
</span><span class="uncovered1"><a name="line398"></a>398         [self.name,self.description,self.order,self.disabled?]
</span><span class="uncovered0"><a name="line399"></a>399       end
</span><span class="uncovered1"><a name="line400"></a>400     end
</span><span class="inferred0"><a name="line401"></a>401     
</span><span class="marked1"><a name="line402"></a>402     module InstanceMethods
</span><span class="inferred0"><a name="line403"></a>403       
</span><span class="inferred1"><a name="line404"></a>404       # Loops through each dependency and runs applicable tests until one passes
</span><span class="inferred0"><a name="line405"></a>405       # 
</span><span class="inferred1"><a name="line406"></a>406       # @api private
</span><span class="marked0"><a name="line407"></a>407       def test!
</span><span class="marked1"><a name="line408"></a>408         dependencies.each do |dep|   
</span><span class="marked0"><a name="line409"></a>409           self.class.tests.each{ |test_meta|  
</span><span class="marked1"><a name="line410"></a>410             dep.met = process_block :test, dep, test_meta
</span><span class="marked0"><a name="line411"></a>411             break if dep.met
</span><span class="inferred1"><a name="line412"></a>412           }
</span><span class="inferred0"><a name="line413"></a>413         end
</span><span class="marked1"><a name="line414"></a>414       end
</span><span class="inferred0"><a name="line415"></a>415       
</span><span class="inferred1"><a name="line416"></a>416       # Loops through dependencies and runs applicable resolutions until one passes
</span><span class="inferred0"><a name="line417"></a>417       #
</span><span class="inferred1"><a name="line418"></a>418       # @api private
</span><span class="marked0"><a name="line419"></a>419       def resolve!
</span><span class="marked1"><a name="line420"></a>420         dependencies.each do |dep|
</span><span class="marked0"><a name="line421"></a>421           self.class.resolutions.each{ |resolution_meta|     
</span><span class="marked1"><a name="line422"></a>422             dep.resolved = process_block :resolution, dep, resolution_meta
</span><span class="marked0"><a name="line423"></a>423             break if dep.resolved
</span><span class="inferred1"><a name="line424"></a>424           }
</span><span class="inferred0"><a name="line425"></a>425         end
</span><span class="marked1"><a name="line426"></a>426       end
</span><span class="inferred0"><a name="line427"></a>427       
</span><span class="inferred1"><a name="line428"></a>428       # list of unresolved dependencies
</span><span class="inferred0"><a name="line429"></a>429       #
</span><span class="inferred1"><a name="line430"></a>430       # @return [Array&lt;Objects&gt;]
</span><span class="inferred0"><a name="line431"></a>431       #   dependencies that weren't resolved
</span><span class="inferred1"><a name="line432"></a>432       #
</span><span class="inferred0"><a name="line433"></a>433       # @api private
</span><span class="marked1"><a name="line434"></a>434       def unresolved
</span><span class="marked0"><a name="line435"></a>435         dependencies.inject([]){ |list,dep| 
</span><span class="marked1"><a name="line436"></a>436           if !dep.met &amp;&amp; !dep.resolved
</span><span class="marked0"><a name="line437"></a>437             list &lt;&lt; dep 
</span><span class="uncovered1"><a name="line438"></a>438           else
</span><span class="uncovered0"><a name="line439"></a>439             list
</span><span class="uncovered1"><a name="line440"></a>440           end
</span><span class="uncovered0"><a name="line441"></a>441         }
</span><span class="marked1"><a name="line442"></a>442       end
</span><span class="inferred0"><a name="line443"></a>443       
</span><span class="inferred1"><a name="line444"></a>444       # list of failed dependencies
</span><span class="inferred0"><a name="line445"></a>445       #
</span><span class="inferred1"><a name="line446"></a>446       # @return [Array&lt;Objects&gt;]
</span><span class="inferred0"><a name="line447"></a>447       #   failed dependencies
</span><span class="inferred1"><a name="line448"></a>448       # 
</span><span class="inferred0"><a name="line449"></a>449       # @api private
</span><span class="marked1"><a name="line450"></a>450       def failed
</span><span class="marked0"><a name="line451"></a>451         dependencies.inject([]){ |list,dep|
</span><span class="marked1"><a name="line452"></a>452           unless dep.met
</span><span class="marked0"><a name="line453"></a>453             list &lt;&lt; dep
</span><span class="inferred1"><a name="line454"></a>454           else
</span><span class="marked0"><a name="line455"></a>455             list
</span><span class="inferred1"><a name="line456"></a>456           end
</span><span class="inferred0"><a name="line457"></a>457         }
</span><span class="marked1"><a name="line458"></a>458       end
</span><span class="inferred0"><a name="line459"></a>459       
</span><span class="inferred1"><a name="line460"></a>460       # list of successful dependencies
</span><span class="inferred0"><a name="line461"></a>461       #
</span><span class="inferred1"><a name="line462"></a>462       # @return [Array&lt;Objects&gt;]
</span><span class="inferred0"><a name="line463"></a>463       # @api private
</span><span class="marked1"><a name="line464"></a>464       def passed
</span><span class="marked0"><a name="line465"></a>465         dependencies.inject([]){ |list,dep| 
</span><span class="marked1"><a name="line466"></a>466           if dep.met
</span><span class="marked0"><a name="line467"></a>467             list &lt;&lt; dep
</span><span class="inferred1"><a name="line468"></a>468           else
</span><span class="marked0"><a name="line469"></a>469             list
</span><span class="inferred1"><a name="line470"></a>470           end
</span><span class="inferred0"><a name="line471"></a>471         }
</span><span class="marked1"><a name="line472"></a>472       end
</span><span class="inferred0"><a name="line473"></a>473       
</span><span class="inferred1"><a name="line474"></a>474       # list of resolved dependencies
</span><span class="inferred0"><a name="line475"></a>475       #
</span><span class="inferred1"><a name="line476"></a>476       # @return [Array&lt;Objects&gt;]
</span><span class="inferred0"><a name="line477"></a>477       #   resolved dependencies
</span><span class="inferred1"><a name="line478"></a>478       #
</span><span class="inferred0"><a name="line479"></a>479       # @api private
</span><span class="marked1"><a name="line480"></a>480       def resolved        
</span><span class="marked0"><a name="line481"></a>481         dependencies.inject([]){ |list,dep| 
</span><span class="marked1"><a name="line482"></a>482           if(!dep.met &amp;&amp; dep.resolved)
</span><span class="marked0"><a name="line483"></a>483             list &lt;&lt; dep 
</span><span class="inferred1"><a name="line484"></a>484           else
</span><span class="marked0"><a name="line485"></a>485             list
</span><span class="inferred1"><a name="line486"></a>486           end
</span><span class="inferred0"><a name="line487"></a>487         }
</span><span class="marked1"><a name="line488"></a>488       end
</span><span class="inferred0"><a name="line489"></a>489       
</span><span class="inferred1"><a name="line490"></a>490       # loads up instance variables for new test
</span><span class="inferred0"><a name="line491"></a>491       # @param *deps [Array]
</span><span class="inferred1"><a name="line492"></a>492       #   Dependencies from YAML file
</span><span class="inferred0"><a name="line493"></a>493       #
</span><span class="inferred1"><a name="line494"></a>494       # @notes
</span><span class="inferred0"><a name="line495"></a>495       #   instance_eval is because I didnt want another class just to track
</span><span class="inferred1"><a name="line496"></a>496       #     met/resolved, if you hate it, feel free to change it :)
</span><span class="inferred0"><a name="line497"></a>497       #       met [Boolean] Was the dependency met
</span><span class="inferred1"><a name="line498"></a>498       #       resolved [Boolean] Was teh dependency resolved
</span><span class="inferred0"><a name="line499"></a>499       #
</span><span class="inferred1"><a name="line500"></a>500       # @api semi-public
</span><span class="marked0"><a name="line501"></a>501       def initialize(*deps)
</span><span class="marked1"><a name="line502"></a>502         @dependencies = Set.new
</span><span class="marked0"><a name="line503"></a>503         deps.each do |dep|
</span><span class="inferred1"><a name="line504"></a>504           # Cast YAML data as described in resolver.
</span><span class="marked0"><a name="line505"></a>505           dep = self.class.yaml_to_object(dep)
</span><span class="inferred1"><a name="line506"></a>506 
</span><span class="marked0"><a name="line507"></a>507           dep.instance_eval { self.class.send(:attr_accessor, :met, :resolved) }
</span><span class="marked1"><a name="line508"></a>508           @dependencies.add dep
</span><span class="inferred0"><a name="line509"></a>509         end
</span><span class="inferred1"><a name="line510"></a>510       end
</span><span class="inferred0"><a name="line511"></a>511           
</span><span class="marked1"><a name="line512"></a>512       attr_accessor :dependencies
</span><span class="inferred0"><a name="line513"></a>513       
</span><span class="marked1"><a name="line514"></a>514       protected
</span><span class="inferred0"><a name="line515"></a>515        # processes a test or resolution block
</span><span class="inferred1"><a name="line516"></a>516        # 
</span><span class="inferred0"><a name="line517"></a>517        # @param type &lt;Symbol&gt;
</span><span class="inferred1"><a name="line518"></a>518        #   The type of block being processed :test | :resolution
</span><span class="inferred0"><a name="line519"></a>519        # 
</span><span class="inferred1"><a name="line520"></a>520        # @param dep &lt;Hash&gt;
</span><span class="inferred0"><a name="line521"></a>521        #    Dependency parsed from yaml configs (Currently Hash)
</span><span class="inferred1"><a name="line522"></a>522        #    TODO; once Dependencies are an object besides Hash, this may need to be changed
</span><span class="inferred0"><a name="line523"></a>523        #
</span><span class="inferred1"><a name="line524"></a>524        # @param block_info &lt;Hash&gt;
</span><span class="inferred0"><a name="line525"></a>525        #   The block details and proc
</span><span class="inferred1"><a name="line526"></a>526        #
</span><span class="inferred0"><a name="line527"></a>527        # @return &lt;Boolean&gt;
</span><span class="inferred1"><a name="line528"></a>528        #   Was the block successful; meaning conditions passed and block returned true
</span><span class="inferred0"><a name="line529"></a>529        #
</span><span class="inferred1"><a name="line530"></a>530        # @api private
</span><span class="marked0"><a name="line531"></a>531        def process_block(type, dep, block_info)
</span><span class="marked1"><a name="line532"></a>532          if !block_info[:if] &amp;&amp; !block_info[:unless]
</span><span class="inferred0"><a name="line533"></a>533            # no condition, run block
</span><span class="marked1"><a name="line534"></a>534            return block_info[type].call(dep)
</span><span class="marked0"><a name="line535"></a>535          elsif block_info[:if] &amp;&amp; block_info[:if].call(dep)
</span><span class="inferred1"><a name="line536"></a>536            #if Condition given and it applies, run block          
</span><span class="marked0"><a name="line537"></a>537            return block_info[type].call(dep)
</span><span class="marked1"><a name="line538"></a>538          elsif block_info[:unless] &amp;&amp; !block_info[:unless].call(dep)
</span><span class="uncovered0"><a name="line539"></a>539            #unless Condition given and it applies, run block
</span><span class="uncovered1"><a name="line540"></a>540            return block_info[type].call(dep)
</span><span class="uncovered0"><a name="line541"></a>541          end
</span><span class="inferred1"><a name="line542"></a>542 
</span><span class="marked0"><a name="line543"></a>543          return false
</span><span class="inferred1"><a name="line544"></a>544        end
</span><span class="inferred0"><a name="line545"></a>545     end
</span><span class="inferred1"><a name="line546"></a>546     
</span><span class="marked0"><a name="line547"></a>547     @@descendents = []
</span><span class="marked1"><a name="line548"></a>548     def self.descendents
</span><span class="inferred0"><a name="line549"></a>549       #Filter out descendents that are disabled
</span><span class="marked1"><a name="line550"></a>550       temp_descendents = []
</span><span class="marked0"><a name="line551"></a>551       @@descendents.each do |klass|
</span><span class="marked1"><a name="line552"></a>552         temp_descendents.push(klass) unless klass.disabled?
</span><span class="inferred0"><a name="line553"></a>553       end
</span><span class="inferred1"><a name="line554"></a>554 
</span><span class="inferred0"><a name="line555"></a>555       #Sort by order
</span><span class="marked1"><a name="line556"></a>556       temp_descendents.sort_by{|desc| desc.order}
</span><span class="inferred0"><a name="line557"></a>557     end
</span><span class="inferred1"><a name="line558"></a>558 
</span><span class="inferred0"><a name="line559"></a>559     
</span><span class="marked1"><a name="line560"></a>560     private
</span><span class="marked0"><a name="line561"></a>561     def self.included(subclass)
</span><span class="marked1"><a name="line562"></a>562       subclass.extend ClassMethods
</span><span class="marked0"><a name="line563"></a>563       subclass.send :include, InstanceMethods
</span><span class="marked1"><a name="line564"></a>564       subclass.send :include, WarningShot::Utilities
</span><span class="marked0"><a name="line565"></a>565       @@descendents.push subclass
</span><span class="inferred1"><a name="line566"></a>566     end
</span><span class="inferred0"><a name="line567"></a>567   end
</span><span class="inferred1"><a name="line568"></a>568 end
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.8.1.2.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
